# 登录状态保存 - 线程架构说明

## 问题背景

### 原始问题
Playwright 的对象（`Browser`, `Context`, `Page`）必须在**创建它们的线程**中使用。如果在不同的线程中调用这些对象的方法，会抛出错误：

```
greenlet.error: cannot switch to a different thread (which happens to have exited)
```

### 场景说明

1. **创建浏览器**：在后台线程 A 中启动 Playwright
2. **用户操作**：用户在浏览器中完成登录
3. **保存状态**：在主线程 B 中调用 `context.storage_state()`
4. **❌ 结果**：跨线程访问错误

## 解决方案：命令队列模式

### 架构设计

使用**生产者-消费者模式**，让浏览器线程持续运行并监听命令：

```
┌─────────────────────────────────────────────────────────┐
│                     主线程 (FastAPI)                     │
│                                                          │
│  1. 接收 HTTP 请求 (POST /auth-state/create)            │
│  2. 启动浏览器线程                                       │
│  3. 接收 HTTP 请求 (POST /auth-state/save)              │
│  4. 发送命令到命令队列 ──────────┐                      │
│  5. 等待结果队列的响应           │                      │
│                                  │                      │
└──────────────────────────────────┼──────────────────────┘
                                   │
                                   │ command_queue.put('save')
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────┐
│              浏览器线程 (Playwright Thread)              │
│                                                          │
│  1. 启动 Playwright                                      │
│  2. 打开浏览器，访问登录页面                             │
│  3. 进入循环，监听命令队列                               │
│     while running:                                       │
│         cmd = command_queue.get(timeout=1)              │
│         if cmd == 'save':                               │
│             - 调用 context.storage_state()              │
│             - 关闭浏览器                                │
│             - 放入结果到 result_queue                   │
│             - 退出循环                                  │
│         elif cmd == 'cancel':                           │
│             - 关闭浏览器                                │
│             - 退出循环                                  │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### 核心代码实现

#### 1. 创建浏览器会话（带命令队列）

```python
def start_browser_session():
    playwright = sync_playwright().start()
    browser = playwright.chromium.launch(headless=False)
    context = browser.new_context()
    page = context.new_page()
    
    # 创建命令队列和结果队列
    command_queue = queue.Queue()
    result_queue = queue.Queue()
    
    # 保存到全局字典
    auth_browser_sessions[project_id] = {
        'playwright': playwright,
        'browser': browser,
        'context': context,
        'page': page,
        'ready': True,
        'command_queue': command_queue,
        'result_queue': result_queue,
        'running': True
    }
    
    page.goto(login_url)
    
    # 监听命令
    while auth_browser_sessions.get(project_id, {}).get('running', False):
        try:
            cmd = command_queue.get(timeout=1)
            
            if cmd == 'save':
                # 在同一线程中执行保存
                auth_manager = AuthStateManager()
                result = auth_manager.save_auth_state(project_id, context)
                browser.close()
                playwright.stop()
                result_queue.put({"success": True, "data": result})
                break
                
            elif cmd == 'cancel':
                browser.close()
                playwright.stop()
                result_queue.put({"success": True})
                break
                
        except queue.Empty:
            continue
```

#### 2. 保存认证状态（发送命令）

```python
@router.post("/projects/{project_id}/auth-state/save")
async def save_auth_state(project_id: int, ...):
    session = auth_browser_sessions[project_id]
    command_queue = session.get('command_queue')
    result_queue = session.get('result_queue')
    
    # 发送保存命令
    command_queue.put('save')
    
    # 等待结果
    result_data = result_queue.get(timeout=30)
    
    # 清理会话
    del auth_browser_sessions[project_id]
    
    return result_data["data"]
```

## 关键优势

### ✅ 线程安全
- Playwright 对象始终在同一个线程中使用
- 通过队列进行线程间通信，避免直接访问

### ✅ 异步非阻塞
- 浏览器线程独立运行
- 主线程不会被浏览器启动阻塞

### ✅ 可扩展
- 可以添加更多命令（如 refresh、screenshot 等）
- 命令模式易于维护和测试

### ✅ 超时控制
- 命令执行有 30 秒超时保护
- 避免无限等待

## 队列说明

### command_queue（命令队列）
- **类型**：`queue.Queue()`
- **方向**：主线程 → 浏览器线程
- **内容**：命令字符串（'save', 'cancel'）
- **用途**：主线程发送指令给浏览器线程

### result_queue（结果队列）
- **类型**：`queue.Queue()`
- **方向**：浏览器线程 → 主线程
- **内容**：执行结果（字典）
- **用途**：浏览器线程返回执行结果

## 生命周期

```
1. 创建会话
   ├─ 主线程：POST /auth-state/create
   ├─ 启动浏览器线程
   ├─ 浏览器打开登录页面
   └─ 浏览器线程进入监听循环

2. 用户登录
   ├─ 用户在浏览器中操作
   └─ 浏览器线程持续运行（等待命令）

3. 保存状态
   ├─ 主线程：POST /auth-state/save
   ├─ 发送 'save' 命令到命令队列
   ├─ 浏览器线程接收命令
   ├─ 执行 storage_state()
   ├─ 关闭浏览器
   ├─ 返回结果到结果队列
   ├─ 主线程接收结果
   ├─ 清理会话
   └─ 浏览器线程退出

4. 取消会话（可选）
   ├─ 主线程：POST /auth-state/cancel
   ├─ 发送 'cancel' 命令到命令队列
   ├─ 浏览器线程关闭浏览器
   └─ 浏览器线程退出
```

## 错误处理

### 超时处理
```python
try:
    result_data = result_queue.get(timeout=30)
except queue.Empty:
    raise HTTPException(detail="保存操作超时")
```

### 异常处理
- 浏览器线程内部捕获异常
- 将错误信息放入结果队列
- 主线程根据结果判断成功或失败

### 会话清理
- 无论成功或失败，都会清理全局会话字典
- 避免内存泄漏

## 测试建议

### 单元测试
1. 测试命令队列的发送和接收
2. 测试超时场景
3. 测试异常场景

### 集成测试
1. 完整的创建-保存流程
2. 创建-取消流程
3. 并发多个项目的会话管理

### 压力测试
1. 多个项目同时创建会话
2. 长时间运行的浏览器会话
3. 快速创建和取消

## 性能优化

### 已实现
- ✅ 使用 `daemon=True` 的后台线程
- ✅ 队列超时避免无限等待
- ✅ 及时清理会话资源

### 可优化
- 🔄 添加会话池管理
- 🔄 添加会话过期自动清理
- 🔄 添加监控和日志记录

## 总结

通过**命令队列模式**，我们成功解决了 Playwright 的线程安全问题：
- Playwright 对象始终在创建它的线程中使用
- 主线程通过队列与浏览器线程通信
- 避免了跨线程访问错误
- 保持了代码的简洁和可维护性
